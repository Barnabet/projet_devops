name: ğŸš€ Production Deployment

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'

env:
  PYTHON_VERSION: '3.9'
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
  RAILWAY_PROJECT_ID: ${{ secrets.RAILWAY_PROJECT_ID }}
  DAGSHUB_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
  DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}

jobs:
  build-and-deploy:
    name: ğŸš€ Build & Deploy to Production
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Install Dependencies
      run: |
        cd backend
        pip install -r requirements.txt
    
    - name: ğŸ¤– Fetch Latest Model from MLflow
      env:
        DAGSHUB_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
        DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}
        MLFLOW_TRACKING_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
        MLFLOW_TRACKING_PASSWORD: ${{ secrets.DAGSHUB_TOKEN }}
      run: |
        echo "ğŸ” Fetching latest model from DagsHub MLflow..."
        
        # Verify environment variables are set
        if [ -z "$DAGSHUB_USERNAME" ] || [ -z "$DAGSHUB_TOKEN" ]; then
          echo "âŒ Error: DAGSHUB_USERNAME and DAGSHUB_TOKEN must be set as GitHub secrets"
          exit 1
        fi
        
        echo "âœ… DagsHub credentials found"
        
        # Create model fetching script
        cat > fetch_model.py << 'EOF'
        import os
        import mlflow
        import dagshub
        from pathlib import Path
        
        # Set DagsHub credentials from environment variables
        dagshub_username = os.environ.get('DAGSHUB_USERNAME')
        dagshub_token = os.environ.get('DAGSHUB_TOKEN')
        
        if not dagshub_username or not dagshub_token:
            raise ValueError("DAGSHUB_USERNAME and DAGSHUB_TOKEN environment variables must be set")
        
        print(f"ğŸ” Authenticating with DagsHub as user: {dagshub_username}")
        
        # Set MLflow environment variables for authentication (bypasses OAuth)
        os.environ['MLFLOW_TRACKING_USERNAME'] = dagshub_username
        os.environ['MLFLOW_TRACKING_PASSWORD'] = dagshub_token
        
        # Set MLflow tracking URI (without credentials in URL to avoid double auth)
        mlflow.set_tracking_uri("https://dagshub.com/Barnabet/projet_devops.mlflow")
        
        print("âœ… DagsHub authentication configured")
        
        try:
            # Get the latest model version in Production stage
            client = mlflow.MlflowClient()
            model_name = "diamond-price-regressor"
            
            # Get latest production model
            latest_versions = client.get_latest_versions(model_name, stages=["Production"])
            
            if latest_versions:
                latest_version = latest_versions[0]
                print(f"ğŸ“¦ Found model version: {latest_version.version}")
                print(f"ğŸ”— Model URI: {latest_version.source}")
                
                # Download the model
                model_path = f"models:/{model_name}/Production"
                local_path = "./model_artifacts"
                
                print(f"â¬‡ï¸ Downloading model to {local_path}...")
                mlflow.artifacts.download_artifacts(artifact_uri=model_path, dst_path=local_path)
                
                # Create model info file
                model_info = {
                    "model_name": model_name,
                    "version": latest_version.version,
                    "stage": "Production",
                    "run_id": latest_version.run_id,
                    "source": latest_version.source,
                    "download_path": local_path
                }
                
                import json
                with open("model_info.json", "w") as f:
                    json.dump(model_info, f, indent=2)
                
                print("âœ… Model downloaded successfully!")
                
            else:
                print("âš ï¸ No Production model found. Using fallback model.")
                # Create empty model info for fallback
                with open("model_info.json", "w") as f:
                    json.dump({"status": "no_model"}, f)
                    
        except Exception as e:
            print(f"âŒ Error fetching model: {e}")
            print("âš ï¸ Will use fallback model in production.")
            with open("model_info.json", "w") as f:
                json.dump({"status": "error", "error": str(e)}, f)
        EOF
        
        # Run the model fetching script
        python fetch_model.py
        
        # Show model info
        if [ -f "model_info.json" ]; then
          echo "ğŸ“Š Model Information:"
          cat model_info.json
        fi
    
    - name: ğŸ·ï¸ Generate Docker Image Tag
      run: echo "IMAGE_TAG=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
    
    - name: ğŸ—ï¸ Prepare Application for Deployment
      run: |
        echo "ğŸ—ï¸ Preparing application for deployment..."
        
        # Copy model artifacts to backend if they exist
        if [ -d "model_artifacts" ]; then
          cp -r model_artifacts backend/
          echo "âœ… Model artifacts copied to backend"
        fi
        
        if [ -f "model_info.json" ]; then
          cp model_info.json backend/
          echo "âœ… Model info copied to backend"
        fi
        
        # Build and test images locally for verification
        echo "ğŸ§ª Building images for local testing..."
        docker build -t diamond-backend-test -f backend/Dockerfile .
        docker build -t diamond-frontend-test -f frontend/Dockerfile frontend/
        
        echo "âœ… Application prepared for deployment!"
    
    - name: ğŸ§ª Test Application Locally
      run: |
        echo "ğŸ§ª Testing application locally..."
        
        # Create Docker network for container communication
        echo "ğŸ”— Creating Docker network..."
        docker network create test-network
        
        # Test backend image
        echo "ğŸ” Testing backend container..."
        docker run -d --name test-backend --network test-network --network-alias backend -p 5001:5000 \
          -e DAGSHUB_USERNAME=${{ env.DAGSHUB_USERNAME }} \
          -e DAGSHUB_TOKEN=${{ env.DAGSHUB_TOKEN }} \
          -e MLFLOW_TRACKING_USERNAME=${{ env.DAGSHUB_USERNAME }} \
          -e MLFLOW_TRACKING_PASSWORD=${{ env.DAGSHUB_TOKEN }} \
          diamond-backend-test
        
        # Test frontend image
        echo "ğŸ” Testing frontend container..."
        docker run -d --name test-frontend --network test-network -p 8080:80 \
          diamond-frontend-test
        
        # Wait for containers to start
        echo "â³ Waiting for containers to start..."
        sleep 15
        
        # Check if containers are running
        echo "ğŸ“Š Container status:"
        docker ps --filter "name=test-backend" --filter "name=test-frontend"
        
        # Check backend container health
        if docker ps --filter "name=test-backend" --filter "status=running" --quiet | grep -q .; then
          echo "âœ… Backend container is running"
          echo "ğŸ“‹ Backend logs:"
          docker logs test-backend --tail 10
          
          # Quick health check (with timeout)
          echo "ğŸ” Testing backend health..."
          if timeout 10 curl -f http://localhost:5001/health; then
            echo "âœ… Backend health check passed!"
          else
            echo "âš ï¸ Backend health check failed, but container is running"
            echo "ğŸ“‹ More backend logs:"
            docker logs test-backend --tail 20
          fi
        else
          echo "âŒ Backend container failed to start"
          echo "ğŸ“‹ Backend logs:"
          docker logs test-backend
          exit 1
        fi
        
        # Check frontend container health
        if docker ps --filter "name=test-frontend" --filter "status=running" --quiet | grep -q .; then
          echo "âœ… Frontend container is running"
          echo "ğŸ“‹ Frontend logs:"
          docker logs test-frontend --tail 5
          
          # Quick health check
          echo "ğŸ” Testing frontend health..."
          if timeout 5 curl -f http://localhost:8080/health; then
            echo "âœ… Frontend health check passed!"
          else
            echo "âš ï¸ Frontend health check failed, but container is running"
          fi
        else
          echo "âŒ Frontend container failed to start"
          echo "ğŸ“‹ Frontend logs:"
          docker logs test-frontend
          exit 1
        fi
        
        echo "âœ… Application tested successfully!"
        
        # Cleanup test containers and network
        echo "ğŸ§¹ Cleaning up test containers and network..."
        docker stop test-backend test-frontend || true
        docker rm test-backend test-frontend || true
        docker network rm test-network || true
    
    - name: ğŸš‚ Install Railway CLI
      run: |
        echo "ğŸ“¦ Installing Railway CLI..."
        curl -fsSL https://railway.app/install.sh | sh
        export PATH=$PATH:~/.railway/bin
        echo "$HOME/.railway/bin" >> $GITHUB_PATH
    
    - name: ğŸš‚ Deploy Backend to Railway
      env:
        RAILWAY_TOKEN: ${{ env.RAILWAY_TOKEN }}
      run: |
        echo "ğŸš‚ Deploying Backend to Railway..."
        echo "â³ This will take approximately 4-5 minutes..."
        
        # Deploy backend service from source (wait for completion)
        railway up \
          --service diamond-backend \
          --environment production
        
        echo "âœ… Backend deployment completed!"

    - name: ğŸš‚ Deploy Frontend to Railway  
      env:
        RAILWAY_TOKEN: ${{ env.RAILWAY_TOKEN }}
      run: |
        echo "ğŸš‚ Deploying Frontend to Railway..."
        echo "â³ This will take approximately 2-3 minutes..."
        
        # Deploy frontend service from source (wait for completion)
        railway up \
          --service diamond-frontend \
          --environment production
        
        echo "âœ… Frontend deployment completed!"

    - name: ğŸŒ Get Deployment URLs
      id: get-urls
      env:
        RAILWAY_TOKEN: ${{ env.RAILWAY_TOKEN }}
      run: |
        echo "ğŸ” Fetching deployment URLs..."
        
        # Get backend URL with retry logic
        echo "ğŸ” Getting backend URL..."
        BACKEND_URL=""
        for i in {1..5}; do
          BACKEND_URL=$(railway domain \
            --service diamond-backend \
            --environment production \
            2>/dev/null | tail -n1 | tr -d '\n\r')
          
          if [ -n "$BACKEND_URL" ] && [ "$BACKEND_URL" != "" ]; then
            echo "âœ… Backend URL found: $BACKEND_URL"
            break
          else
            echo "â³ Attempt $i/5: Backend URL not ready, waiting 30s..."
            sleep 30
          fi
        done
        
        # Get frontend URL with retry logic
        echo "ğŸ” Getting frontend URL..."
        FRONTEND_URL=""
        for i in {1..5}; do
          FRONTEND_URL=$(railway domain \
            --service diamond-frontend \
            --environment production \
            2>/dev/null | tail -n1 | tr -d '\n\r')
          
          if [ -n "$FRONTEND_URL" ] && [ "$FRONTEND_URL" != "" ]; then
            echo "âœ… Frontend URL found: $FRONTEND_URL"
            break
          else
            echo "â³ Attempt $i/5: Frontend URL not ready, waiting 30s..."
            sleep 30
          fi
        done
        
        # Validate URLs
        if [ -z "$BACKEND_URL" ] || [ "$BACKEND_URL" = "" ]; then
          echo "âŒ Failed to get backend URL after retries"
          BACKEND_URL="https://your-backend-service.railway.app"
        fi
        
        if [ -z "$FRONTEND_URL" ] || [ "$FRONTEND_URL" = "" ]; then
          echo "âŒ Failed to get frontend URL after retries"  
          FRONTEND_URL="https://your-frontend-service.railway.app"
        fi
        
        # Ensure URLs have https:// prefix
        if [[ ! "$BACKEND_URL" =~ ^https?:// ]]; then
          BACKEND_URL="https://$BACKEND_URL"
        fi
        
        if [[ ! "$FRONTEND_URL" =~ ^https?:// ]]; then
          FRONTEND_URL="https://$FRONTEND_URL"
        fi
        
        echo "DEPLOYMENT_URL=$BACKEND_URL" >> $GITHUB_OUTPUT
        echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "ğŸŒ Final Backend URL: $BACKEND_URL"
        echo "ğŸŒ Final Frontend URL: $FRONTEND_URL"
    
    - name: ğŸ§ª Test Production Deployment
      run: |
        echo "ğŸ§ª Testing production deployment..."
        
        DEPLOYMENT_URL="${{ steps.get-urls.outputs.DEPLOYMENT_URL }}"
        FRONTEND_URL="${{ steps.get-urls.outputs.FRONTEND_URL }}"
        
        echo "ğŸ” Testing URLs:"
        echo "   Backend: $DEPLOYMENT_URL"
        echo "   Frontend: $FRONTEND_URL"
        
        # Wait additional time for services to be fully ready
        echo "â³ Waiting for services to be fully ready..."
        sleep 30
        
        # Test backend health endpoint with retries
        echo "ğŸ” Testing backend health endpoint..."
        HEALTH_SUCCESS=false
        for i in {1..5}; do
          if curl -f --max-time 30 "$DEPLOYMENT_URL/health"; then
            echo "âœ… Backend health check passed!"
            HEALTH_SUCCESS=true
            break
          else
            echo "â³ Attempt $i/5: Backend health check failed, waiting 30s..."
            sleep 30
          fi
        done
        
        if [ "$HEALTH_SUCCESS" = false ]; then
          echo "âš ï¸ Backend health check failed after 5 attempts"
        fi
        
        # Test frontend health endpoint with retries
        echo "ğŸ” Testing frontend health endpoint..."
        FRONTEND_SUCCESS=false
        for i in {1..3}; do
          if curl -f --max-time 30 "$FRONTEND_URL/health"; then
            echo "âœ… Frontend health check passed!"
            FRONTEND_SUCCESS=true
            break
          else
            echo "â³ Attempt $i/3: Frontend health check failed, waiting 15s..."
            sleep 15
          fi
        done
        
        if [ "$FRONTEND_SUCCESS" = false ]; then
          echo "âš ï¸ Frontend health check failed after 3 attempts"
        fi
        
        # Test prediction endpoint with retries
        echo "ğŸ§ª Testing prediction endpoint..."
        PREDICTION_SUCCESS=false
        for i in {1..3}; do
          if curl -X POST --max-time 30 "$DEPLOYMENT_URL/predict" \
            -H "Content-Type: application/json" \
            -d '{"carat": 1.0, "cut": "Ideal", "color": "H", "clarity": "SI1", "depth": 61.5, "table": 55.0, "x": 6.3, "y": 6.54, "z": 4.0}'; then
            echo "âœ… Prediction endpoint test passed!"
            PREDICTION_SUCCESS=true
            break
          else
            echo "â³ Attempt $i/3: Prediction test failed, waiting 15s..."
            sleep 15
          fi
        done
        
        if [ "$PREDICTION_SUCCESS" = false ]; then
          echo "âš ï¸ Prediction test failed after 3 attempts"
        fi
        
        echo "âœ… Production deployment testing completed!"
    
    - name: ğŸ“Š Generate Deployment Report
      run: |
        echo "## ğŸš€ Production Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Model**: Latest from MLflow Production stage" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Application**: Built and tested locally" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Deployment**: Successfully deployed to Railway from source" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Health Check**: Production endpoints verified" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸŒ **Backend URL**: ${{ steps.get-urls.outputs.DEPLOYMENT_URL }}" >> $GITHUB_STEP_SUMMARY
        echo "ğŸŒ **Frontend URL**: ${{ steps.get-urls.outputs.FRONTEND_URL }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ‰ **Production deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
    
    - name: ğŸ“¢ Notify Deployment Success
      run: |
        echo "ğŸ‰ Production deployment completed!"
        echo "ğŸŒ Backend is live at: ${{ steps.get-urls.outputs.DEPLOYMENT_URL }}"
        echo "ğŸŒ Frontend is live at: ${{ steps.get-urls.outputs.FRONTEND_URL }}"
        echo "ğŸš‚ Railway deployment method: Build from source"