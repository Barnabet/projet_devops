name: ğŸš€ Production Deployment

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'

env:
  PYTHON_VERSION: '3.9'
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
  RAILWAY_PROJECT_ID: ${{ secrets.RAILWAY_PROJECT_ID }}
  DAGSHUB_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
  DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}

jobs:
  build-and-deploy:
    name: ğŸš€ Build & Deploy to Production
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Install Dependencies
      run: |
        cd backend
        pip install -r requirements.txt
    
    - name: ğŸ¤– Fetch Latest Model from MLflow
      env:
        DAGSHUB_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
        DAGSHUB_TOKEN: ${{ secrets.DAGSHUB_TOKEN }}
        MLFLOW_TRACKING_USERNAME: ${{ secrets.DAGSHUB_USERNAME }}
        MLFLOW_TRACKING_PASSWORD: ${{ secrets.DAGSHUB_TOKEN }}
      run: |
        echo "ğŸ” Fetching latest model from DagsHub MLflow..."
        
        # Verify environment variables are set
        if [ -z "$DAGSHUB_USERNAME" ] || [ -z "$DAGSHUB_TOKEN" ]; then
          echo "âŒ Error: DAGSHUB_USERNAME and DAGSHUB_TOKEN must be set as GitHub secrets"
          exit 1
        fi
        
        echo "âœ… DagsHub credentials found"
        
        # Create model fetching script
        cat > fetch_model.py << 'EOF'
        import os
        import mlflow
        import dagshub
        from pathlib import Path
        
        # Set DagsHub credentials from environment variables
        dagshub_username = os.environ.get('DAGSHUB_USERNAME')
        dagshub_token = os.environ.get('DAGSHUB_TOKEN')
        
        if not dagshub_username or not dagshub_token:
            raise ValueError("DAGSHUB_USERNAME and DAGSHUB_TOKEN environment variables must be set")
        
        print(f"ğŸ” Authenticating with DagsHub as user: {dagshub_username}")
        
        # Set MLflow environment variables for authentication (bypasses OAuth)
        os.environ['MLFLOW_TRACKING_USERNAME'] = dagshub_username
        os.environ['MLFLOW_TRACKING_PASSWORD'] = dagshub_token
        
        # Set MLflow tracking URI (without credentials in URL to avoid double auth)
        mlflow.set_tracking_uri("https://dagshub.com/Barnabet/projet_devops.mlflow")
        
        print("âœ… DagsHub authentication configured")
        
        try:
            # Get the latest model version in Production stage
            client = mlflow.MlflowClient()
            model_name = "diamond-price-regressor"
            
            # Get latest production model
            latest_versions = client.get_latest_versions(model_name, stages=["Production"])
            
            if latest_versions:
                latest_version = latest_versions[0]
                print(f"ğŸ“¦ Found model version: {latest_version.version}")
                print(f"ğŸ”— Model URI: {latest_version.source}")
                
                # Download the model
                model_path = f"models:/{model_name}/Production"
                local_path = "./model_artifacts"
                
                print(f"â¬‡ï¸ Downloading model to {local_path}...")
                mlflow.artifacts.download_artifacts(artifact_uri=model_path, dst_path=local_path)
                
                # Create model info file
                model_info = {
                    "model_name": model_name,
                    "version": latest_version.version,
                    "stage": "Production",
                    "run_id": latest_version.run_id,
                    "source": latest_version.source,
                    "download_path": local_path
                }
                
                import json
                with open("model_info.json", "w") as f:
                    json.dump(model_info, f, indent=2)
                
                print("âœ… Model downloaded successfully!")
                
            else:
                print("âš ï¸ No Production model found. Using fallback model.")
                # Create empty model info for fallback
                with open("model_info.json", "w") as f:
                    json.dump({"status": "no_model"}, f)
                    
        except Exception as e:
            print(f"âŒ Error fetching model: {e}")
            print("âš ï¸ Will use fallback model in production.")
            with open("model_info.json", "w") as f:
                json.dump({"status": "error", "error": str(e)}, f)
        EOF
        
        # Run the model fetching script
        python fetch_model.py
        
        # Show model info
        if [ -f "model_info.json" ]; then
          echo "ğŸ“Š Model Information:"
          cat model_info.json
        fi
    
    - name: ğŸ·ï¸ Generate Docker Image Tag
      run: echo "IMAGE_TAG=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
    
    - name: ğŸ—ï¸ Build Production Docker Images
      run: |
        echo "ğŸ—ï¸ Building production Docker images with latest model..."
        
        # Copy model artifacts to backend if they exist
        if [ -d "model_artifacts" ]; then
          cp -r model_artifacts backend/
          echo "âœ… Model artifacts copied to backend"
        fi
        
        if [ -f "model_info.json" ]; then
          cp model_info.json backend/
          echo "âœ… Model info copied to backend"
        fi
        
        # Build images with production tags
        docker build -t ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:latest \
                     -t ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:${{ env.IMAGE_TAG }} \
                     -f backend/Dockerfile .
        
        docker build -t ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-frontend:latest \
                     -t ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-frontend:${{ env.IMAGE_TAG }} \
                     -f frontend/Dockerfile frontend/
        
        echo "âœ… Docker images built successfully!"
    
    - name: ğŸ§ª Test Production Images
      run: |
        echo "ğŸ§ª Testing production images..."
        
        # Create Docker network for container communication
        echo "ğŸ”— Creating Docker network..."
        docker network create test-network
        
        # Test backend image
        echo "ğŸ” Testing backend container..."
        docker run -d --name test-backend --network test-network --network-alias backend -p 5001:5000 \
          -e DAGSHUB_USERNAME=${{ env.DAGSHUB_USERNAME }} \
          -e DAGSHUB_TOKEN=${{ env.DAGSHUB_TOKEN }} \
          -e MLFLOW_TRACKING_USERNAME=${{ env.DAGSHUB_USERNAME }} \
          -e MLFLOW_TRACKING_PASSWORD=${{ env.DAGSHUB_TOKEN }} \
          ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:latest
        
        # Test frontend image
        echo "ğŸ” Testing frontend container..."
        docker run -d --name test-frontend --network test-network -p 8080:80 \
          ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-frontend:latest
        
        # Wait for containers to start
        echo "â³ Waiting for containers to start..."
        sleep 15
        
        # Check if containers are running
        echo "ğŸ“Š Container status:"
        docker ps --filter "name=test-backend" --filter "name=test-frontend"
        
        # Check backend container health
        if docker ps --filter "name=test-backend" --filter "status=running" --quiet | grep -q .; then
          echo "âœ… Backend container is running"
          echo "ğŸ“‹ Backend logs:"
          docker logs test-backend --tail 10
          
          # Quick health check (with timeout)
          echo "ğŸ” Testing backend health..."
          if timeout 10 curl -f http://localhost:5001/health; then
            echo "âœ… Backend health check passed!"
          else
            echo "âš ï¸ Backend health check failed, but container is running"
            echo "ğŸ“‹ More backend logs:"
            docker logs test-backend --tail 20
          fi
        else
          echo "âŒ Backend container failed to start"
          echo "ğŸ“‹ Backend logs:"
          docker logs test-backend
          exit 1
        fi
        
        # Check frontend container health
        if docker ps --filter "name=test-frontend" --filter "status=running" --quiet | grep -q .; then
          echo "âœ… Frontend container is running"
          echo "ğŸ“‹ Frontend logs:"
          docker logs test-frontend --tail 5
          
          # Quick health check
          echo "ğŸ” Testing frontend health..."
          if timeout 5 curl -f http://localhost:8080/health; then
            echo "âœ… Frontend health check passed!"
          else
            echo "âš ï¸ Frontend health check failed, but container is running"
          fi
        else
          echo "âŒ Frontend container failed to start"
          echo "ğŸ“‹ Frontend logs:"
          docker logs test-frontend
          exit 1
        fi
        
        echo "âœ… Production images tested successfully!"
        
        # Cleanup test containers and network
        echo "ğŸ§¹ Cleaning up test containers and network..."
        docker stop test-backend test-frontend || true
        docker rm test-backend test-frontend || true
        docker network rm test-network || true
    
    - name: ğŸ” Login to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ env.DOCKER_PASSWORD }}
    
    - name: ğŸ“¤ Push Images to Docker Hub
      run: |
        echo "ğŸ“¤ Pushing images to Docker Hub..."
        
        # Push backend images
        docker push ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:latest
        docker push ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:${{ env.IMAGE_TAG }}
        
        # Push frontend images
        docker push ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-frontend:latest
        docker push ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-frontend:${{ env.IMAGE_TAG }}
        
        echo "âœ… Images pushed to Docker Hub successfully!"
    
    - name: ğŸš‚ Deploy to Railway
      run: |
        echo "ğŸš‚ Deploying to Railway CI..."
        # Install Railway CLI
        curl -fsSL https://railway.app/install.sh | sh
        export PATH=$PATH:~/.railway/bin

        # Deploy the latest backend image to the production environment.
        # The project is inferred from the RAILWAY_TOKEN secret.
        railway up \
          --service diamond-backend \
          --environment production \
          --image ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:${{ env.IMAGE_TAG }} \
          --detach

    - name: ğŸŒ Get Deployment URL
      id: get-url
      run: |
        # Fetch public URL for the backend service
        # `railway domain` will return the service's existing domain or generate one if missing.
        # We parse the singleâ€‘line output directlyâ€”no need for JSON or prior `railway link`.
        DEPLOYMENT_URL=$(railway domain \
          --service diamond-backend \
          --environment production \
          2>/dev/null | tail -n1)

        echo "DEPLOYMENT_URL=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
        echo "ğŸŒ Deployment URL: $DEPLOYMENT_URL"
    
    - name: ğŸ§ª Test Production Deployment
      run: |
        echo "ğŸ§ª Testing production deployment..."
        
        DEPLOYMENT_URL="${{ steps.get-url.outputs.DEPLOYMENT_URL }}"
        
        # Wait for deployment to be ready
        echo "â³ Waiting for deployment to be ready..."
        sleep 60
        
        # Test health endpoints
        echo "ğŸ” Testing health endpoints..."
        curl -f "$DEPLOYMENT_URL/health" || echo "âš ï¸ Health check failed"
        
        # Test prediction endpoint
        echo "ğŸ§ª Testing prediction endpoint..."
        curl -X POST "$DEPLOYMENT_URL/predict" \
          -H "Content-Type: application/json" \
          -d '{"carat": 1.0, "cut": "Ideal", "color": "H", "clarity": "SI1", "depth": 61.5, "table": 55.0, "x": 6.3, "y": 6.54, "z": 4.0}' \
          || echo "âš ï¸ Prediction test failed"
        
        echo "âœ… Production deployment tested!"
    
    - name: ğŸ“Š Generate Deployment Report
      run: |
        echo "## ğŸš€ Production Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Model**: Latest from MLflow Production stage" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Docker Images**: Built and pushed to Docker Hub" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Deployment**: Successfully deployed to Railway" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Health Check**: Production endpoints verified" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸŒ **Live URL**: ${{ steps.get-url.outputs.DEPLOYMENT_URL }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ‰ **Production deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
    
    - name: ğŸ“¢ Notify Deployment Success
      run: |
        echo "ğŸ‰ Production deployment completed!"
        echo "ğŸŒ Application is live at: ${{ steps.get-url.outputs.DEPLOYMENT_URL }}"
        echo "ğŸ“¦ Docker images available at:"
        echo "   - Backend: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-backend:latest"
        echo "   - Frontend: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/diamond-frontend:latest" 